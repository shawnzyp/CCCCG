import { readFile, writeFile } from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');
const sourcePath = path.join(rootDir, 'Levels.txt');
const outPath = path.join(rootDir, 'scripts', 'levels.js');

const PROFICIENCY_BY_TIER = new Map([
  [5, 2],
  [4, 3],
  [3, 4],
  [2, 5],
  [1, 6],
  [0, 7],
]);

const LEVEL_REWARD_OVERRIDES = new Map([
  [2, { hpBonus: 5, grantsPowerEvolution: true }],
  [3, { augmentSlots: 1 }],
  [4, { spBonus: 1, grantsSignatureEvolution: true, grantsStatIncrease: true }],
  [5, { hpBonus: 5, grantsPowerEvolution: true }],
  [6, { augmentSlots: 1 }],
  [7, { spBonus: 1, grantsPowerEvolution: true }],
  [8, { powerEvolutionChoice: true, signatureEvolutionChoice: true, grantsStatIncrease: true }],
  [9, { augmentSlots: 1 }],
  [10, { hpBonus: 5, grantsPowerEvolution: true }],
  [11, { spBonus: 1 }],
  [12, { augmentSlots: 1, grantsStatIncrease: true }],
  [13, { hpBonus: 5, grantsPowerEvolution: true }],
  [14, { spBonus: 1 }],
  [15, { augmentSlots: 1 }],
  [16, { grantsLegendaryGearAccess: true, grantsStatIncrease: true }],
  [17, { hpBonus: 5, grantsPowerEvolution: true }],
  [18, { spBonus: 1 }],
  [19, { augmentSlots: 1 }],
  [20, { grantsTranscendentTrait: true, grantsStatIncrease: true }],
]);

function getRewardMetadata(level) {
  const overrides = LEVEL_REWARD_OVERRIDES.get(level);
  if (!overrides) return {};
  return { ...overrides };
}

function parseLevels(text) {
  const lines = text.split(/\r?\n/);
  const entries = [];
  let lastTierLabel = '';
  for (const line of lines) {
    if (!line || !line.trim()) continue;
    if (line.startsWith('CATALYST')) continue;
    if (line.startsWith('Level\tTier')) continue;
    if (line.startsWith('Level Milestone')) break;
    const parts = line.split('\t');
    if (!parts.length) continue;
    const [levelRaw, tierRaw, subTierRaw, xpRaw, tierLabelRaw = '', gainsRaw = ''] = parts;
    const level = Number(levelRaw.trim());
    if (!Number.isFinite(level)) continue;
    const tierNumber = Number(tierRaw.trim());
    const subTier = subTierRaw.trim();
    const xp = Number(xpRaw.replace(/\s+/g, ''));
    let tierLabel = tierLabelRaw.trim();
    if (!tierLabel) tierLabel = lastTierLabel;
    if (!tierLabel) tierLabel = `Tier ${Number.isFinite(tierNumber) ? tierNumber : ''}`.trim();
    lastTierLabel = tierLabel;
    const gains = gainsRaw.trim();
    const proficiencyBonus = PROFICIENCY_BY_TIER.get(tierNumber) || 2;
    const rewards = getRewardMetadata(level);
    entries.push({
      level,
      tierNumber: Number.isFinite(tierNumber) ? tierNumber : null,
      tierLabel,
      subTier,
      xp,
      proficiencyBonus,
      gains,
      rewards,
    });
  }
  return entries;
}

function formatEntries(entries) {
  const lines = entries.map(entry => {
    const { level, tierNumber, tierLabel, subTier, xp, proficiencyBonus, gains, rewards } = entry;
    const data = {
      level,
      tierNumber,
      tierLabel,
      subTier,
      xp,
      proficiencyBonus,
      gains,
      rewards: rewards && typeof rewards === 'object' ? rewards : {},
    };
    const serialized = JSON.stringify(data, null, 2);
    return serialized;
  });
  return `/* eslint-disable */\n// This file is generated by tools/build-levels.mjs\nexport const LEVELS = [\n${lines.map(line => line.split('\n').map((part, idx) => (idx === 0 ? `  ${part}` : `  ${part}`)).join('\n')).join(',\n')}\n];\n`;
}

async function main() {
  const text = await readFile(sourcePath, 'utf8');
  const entries = parseLevels(text);
  if (!entries.length) {
    throw new Error('No level data parsed from Levels.txt');
  }
  const output = formatEntries(entries);
  await writeFile(outPath, output, 'utf8');
}

main().catch(err => {
  console.error(err);
  process.exitCode = 1;
});
